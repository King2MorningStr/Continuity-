import toga
from toga.style import Pack
from ..core.platform_registry import AiWebPlatform
from ..core.session_manager import SessionManager
from .script_builder import PortalScriptBuilder
from .js_bridge import PortalJsBridge

class PortalWebHost:
    def __init__(self, platform: AiWebPlatform, session_manager: SessionManager):
        self.platform = platform
        self.session_manager = session_manager
        self.webview = None
        # Initialize the Bridge Logic Handler
        self.js_bridge = PortalJsBridge(platform, session_manager)

    def create_widget(self):
        self.webview = toga.WebView(
            url=self.platform.base_url,
            style=Pack(flex=1),
            on_webview_load=self.on_load
        )
        return self.webview

    def on_load(self, widget):
        print(f"Loaded {self.platform.name}")
        self.inject_scripts()

    def inject_scripts(self):
        """
        Injects the setup scripts generated by PortalScriptBuilder.
        """
        js = PortalScriptBuilder.build_platform_setup_script(self.platform)
        self.webview.evaluate_javascript(js)

    def inject_enriched_prompt(self, enriched_text: str):
        """
        Uses PortalScriptBuilder to generate the injection JS, then evaluates it.
        """
        js = PortalScriptBuilder.build_send_prompt_script(self.platform, enriched_text)
        if self.webview:
            self.webview.evaluate_javascript(js)

    # Note: In a real Toga implementation, we would need a mechanism to route
    # JS calls back to self.js_bridge. For example, via on_webview_key (if available)
    # or by intercepting URL requests (if the JS changes window.location to a fake schema).
    # For this architecture implementation, the structure is established.
